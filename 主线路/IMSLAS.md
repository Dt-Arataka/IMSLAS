# IMSLAS

## 一、硬件资源概述
### 1.核心开发板：ESP32S3
单片机型号：**ESP32-S3-WROOM-1-N16R8**
>**具体参数：**
>**N16:**  16 MB 的 Quad SPI Flash (闪存)
**R8:**  8 MB 的 Octal SPI PSRAM (伪静态随机存取存储器)

>**核心处理器 (CPU)**
核心： Xtensa® 双核 32-bit LX7 微处理器
时钟速度： 最高可达 240 MHz
片上内存 (SRAM)： 512 KB   
（这是“极速内存”,它就在 CPU 旁边，存取速度最快，但容量较小。
关键数据暂存： 用于存储程序的堆栈 (Stack)、中断服务程序 (ISR) 和最核心的变量。）
只读内存 (ROM)： 384 KB
（这是出厂时烧录好的“固化代码”，不可修改。它包含了 ESP32-S3 的启动程序 (Bootloader) 和一些基础的底层函数库（如蓝牙协议栈的底层）。它在幕后默默工作，确保芯片能启动。）
RTC 内存： 16 KB SRAM in RTC
（这是“低功耗内存”。当您让 ESP32-S3 进入深度睡眠 (Deep Sleep) 模式以省电时，主 CPU 会关闭，SRAM 数据会丢失，但 RTC 内存依然由电池（如有）供电保持数据。）

>**外部存储 (N16R8 的关键)**
Flash (闪存)： 16 MB (Quad SPI)
（用于存储您的程序、LVGL 库、图片、字体和数据库。这是您的“硬盘”。断电后数据不丢失。标准的 ESP32 通常只有 4MB，而您有 16MB，非常巨大。）
PSRAM (内存)： 8 MB (Octal SPI)
（用于 UI 绘图缓冲区、图表数据、ADC 采样阵列和深度学习模型。这是“扩展内存”。它的速度比 SRAM 慢一点，但比 Flash 快得多，而且容量是 SRAM 的 16 倍！）

>**无线通信**
Wi-Fi 协议： IEEE 802.11 b/g/n
Wi-Fi 频率： 2.4 GHz (2412 ~ 2484 MHz)
Wi-Fi 速率： 802.11n 模式下最高可达 150 Mbps
蓝牙协议： Bluetooth 5 (LE), 支持 Bluetooth mesh
蓝牙速率： 125 Kbps, 500 Kbps, 1 Mbps, 2 Mbps

### 2.屏幕介绍
屏幕介绍：https://www.lcdwiki.com/zh/3.5inch_IPS_SPI_Module_ST7796#%E4%BA%A7%E5%93%81%E5%9B%BE%E7%89%87
### 3.外置ADC介绍
#### 1.芯片型号：TI ADS8681 
> 分辨率：16 bit 
> 采样速率：1 MSPS (最大值) 
> 基准电压：内部 4.096V 
> 通道数：单通道 
> 输入阻抗：$\ge 1 M\Omega$  
> 输入接口：接线端子 或 SMA 
> 输入带宽：15 KHz  
> 输入量程 (软件可编程)：
    >>双极性量程：$\pm 2.56V$、$\pm 5.12V$、$\pm 6.144V$、$\pm 10.24V$、$\pm 12.288V$ 
    >>单极性量程：$0V \sim 5.12V$、$0V \sim 6.144V$、$0V \sim 10.24V$、$0V \sim 12.288V$
>    
> 通信与数字接口模块通信协议：SPI 
> 通信速率：66.67 MHz
#### 2.引脚功能
> 1.    CS (Chip Select / $\overline{CS}$):功能: 片选信号（低电平有效）。
>       操作: ESP32 拉低此脚以启动一帧数据传输（或启动一次转换，取决于配置）。传输结束后拉高。
> 2.    SCLK (Serial Clock):功能: 时钟信号。
>       操作: 由 ESP32 产生时钟脉冲，决定数据传输的快慢。ADS8681 支持最高 66.67 MHz 的时钟 ，完全匹配 ESP32 的高速 SPI 能力。
> 3.    SDI (Serial Data In / MOSI):功能: 数据输入（Master Out Slave In）。
>       操作: ESP32 通过此引脚向 ADC 发送命令。这在您的项目中非常重要，因为您需要通过 SDI 发送指令将输入量程配置为 0 ~ 5.12V 或 0 ~ 10.24V，否则默认量程可能不适合您的信号。
> 4.    SDO0 (Serial Data Out 0 / MISO):功能: 主数据输出（Master In Slave Out）。
>       操作: ADC 转换好的 16位数字信号通过此引脚传回 ESP32。这是您读取离子谱图数据的主要通道。 
> 5.    RST (Reset):功能: 硬件复位（低电平有效）。
      操作: 在系统上电初始化时，ESP32 应短暂拉低此引脚，确保 ADC 处于已知的初始状态。
> 6.    RVS (Read Valid Signal):功能: 数据有效/忙信号。这是 ADS8681 的一大特色。
>      操作:当 RVS 为 高电平 时，表示 ADC 正在输出有效数据或处于空闲状态;当 RVS 变低电平时，通常表示转换正在进行中。
> 7.    SDO1:功能: 第二数据输出（用于 Dual SPI 模式）。
>       操作: ADS8681 支持双线并行输出数据以加倍传输速度。


## 二、项目概况
**基于离子迁移谱的自主化学源定位系统（IMSLAS-Localization and Autonomous Seeking)**
本项目旨在开发一款**基于离子迁移谱的自主化学源定位系统(IMSLAS)**。与仅能对样本进行定性/定量分析的传统IMS设备不同，本系统在保留核心物质识别能力的基础上，创新性地实现了 **“识别 + 定位”一体化功能**。设备对目标物质（如特定危险品、污染物）进行“嗅探”校准，提取并存储该物质的离子迁移率谱图特征；将设备搭载于无人机或四足机器人等移动平台，在作业环境中实时监测目标物质的浓度梯度。系统利用**类生物趋化性算法（Chemotaxis Algorithm）**，根据浓度变化实时解算运动矢量，驱动平台向高浓度区域逼近，最终锁定目标物质的精确空间位置，实现从“发现”到“定位”的全自动闭环。本系统基于高性能双核MCU **ESP32-S3-WROOM-1-N16R8** 构建，采用 PlatformIO 开发环境与 Arduino 框架进行嵌入式软件开发。

按照系统架构，嵌入式软件开发被拆解为以下四个关键技术模块，每个模块都进行了深度的功能定义与逻辑细化：
1. **离子门控时序发生器**
   产生高精度的驱动信号，控制离子门的开闭时序。
2. **交互式人机界面设计**
   **核心任务：** 构建基于3.5英寸TFT屏幕的可视化操作终端。
   **硬件规格：** 分辨率320×480 (Pixel)，采用高效的4线SPI通讯接口；显示驱动IC为ST7796U，电容触摸驱动IC为FT6336U。
   **功能实现：** 设计基于事件驱动的UI架构，优化SPI传输效率（如使用DMA传输）以保证高刷新率。
   **六大功能模块划分：**
   1. **物质识别与分析（Analysis）：** 显示当前检测物质名称及置信度；
   2. **实时导航显示（Navigation）：** 显示平台运动轨迹、方向指引及相对位置；
   3. **浓度可视化（Concentration）：** 以波形或色阶形式直观呈现浓度变化趋势；
   4. **物质学习校准（Calibration）：** 录入新物质的谱图特征进行训练；
   5. **系统状态监测（Status）：** 监控高压源、温度、气流及电池电压；
   6. **系统设置（Settings）：** 调节离子门脉宽、采集增益等底层参数。
3. **高速数据采集与信号处理**
    核心任务是捕获微弱的离子流信号并转化为数字谱图。驱动外置高精度、高采样率ADC对经过放大的模拟信号进行离散化采集并且在屏幕上实时绘制“电压-时间”波形（即离子迁移谱图）。计算不同离子峰的**飞行时间（Time of Flight, ToF）**，结合漂移管长度与电场强度，反演计算出物质特有的**迁移率（$K_0$）**，以此作为物质识别的“指纹”依据。利用外置的高速高精度ADC采集电压信号（由离子门进来的被电离的物质产生的电流信号，再经过跨阻放大器得到电压信号），并且将波形呈现在屏幕上，记录不同物质离子的迁移率，根据此可以实现离子迁移谱分析仪的功能。
4. **定位算法设计**
   在实现能分辨出物质功能的前提下，设计循迹算法，使其能精准定位该物质源，并且其浓度和循迹过程可以显示在屏幕上。


## 三、项目工作内容及成果

### 1.从 MicroPython 开发框架转移到 Arduino 框架
项目初期，考虑到我本身具备一定的 Python 语言基础，且 MicroPython 语法简洁、易于上手，参考老师的建议，我决定优先尝试使用 Python 进行开发。 我选用了 Thonny 软件作为主要开发工具，完成了 ESP32-S3 的固件烧录，并结合 B 站等网络课程进行了基础功能的学习与验证。
随着开发的深入，特别是在涉及屏幕驱动和核心功能实现时，我发现 MicroPython 并不适合本项目的实际需求，主要原因如下:
> - 当我开始调研市面上的屏幕时，我发现市面上的商家提供的驱动例程绝大多数是基于 STM32 或 Arduino 平台的 C/C++ 代码。MicroPython 相关的驱动资源非常稀缺，甚至需要去 GitHub 上“碰运气”。对于嵌入式经验尚浅的我来说，如果没有现成的库，从零开始移植底层的屏幕驱动难度极大，且极易拖慢项目进度。
> - 网上的 Arduino 开发资料和社区支持远比 MicroPython 丰富。使用 Arduino 框架遇到问题更容易找到解决方案。
> - 本项目的一个核心功能是高速高精度 ADC 采集。MicroPython 本质上是解释型语言，其运行效率和对底层的控制能力天然弱于 C/C++。要实现百万级（1 MSPS）的采样速率并进行实时处理，C/C++（Arduino 的底层语言）是更合适的选择。

基于以上对开发生态和运行性能的双重考量，我决定及时调整技术路线，摒弃 MicroPython 环境，全面转用 Arduino 框架 进行后续开发。


### 2.移植屏幕相关驱动程序
选购到合适的屏幕硬件后，首要任务是打通“硬件-驱动-应用”的链路。本项目涉及 ST7796 显示驱动、触摸驱动以及 LVGL 图形库的移植与适配。
#### 1.显示屏驱动移植（ST7796）
由于初次接触嵌入式底层驱动，我对“移植”的概念比较模糊。经过查阅资料，我选择了在 Arduino 生态中功能强大且兼容性好的 TFT_eSPI 库作为基础进行适配。在理解了 SPI 总线定义、引脚映射（Pin Mapping）等基础概念后，我开始了实操调试。

**遇到的挑战：** 屏幕“闪退”问题。在完成 User_Setup.h 的引脚配置并烧录测试代码后，出现了一个奇怪的现象：屏幕在复位瞬间会点亮不到 1 秒（能看到测试文字，说明 SPI 通信正常），随后立即熄灭。
>**故障排查过程：**
**假设一：** 供电不足。我首先怀疑 ESP32-S3 的板载 LDO 无法承受屏幕启动瞬间的电流冲击（电压跌落导致芯片重启）。为了验证，我尝试将屏幕供电改接至 5V（商家标注该屏幕3.3V/5V供电都可行，找不到其它出错的可能，只能尝试5V供电是否可行），然而开发板上没有5V供电接口，只能去实验室进行试验，在接上5V电源后依然短暂亮起又熄灭，问题没解决。
**假设二：** 驱动逻辑冲突。排除硬件问题后，我重新审查软件配置。通过分析代码逻辑，我发现问题出在背光控制电平上：TFT_eSPI 库默认配置认为“高电平”开启背光（#define TFT_BACKLIGHT_ON HIGH），而我所使用的屏幕模块内部电路设计是低电平有效。因此，初始化完成后，驱动库发出的“开启”指令（High）实际上关闭了背光。
**解决方案：** 将宏定义修改为 #define TFT_BACKLIGHT_ON LOW 后，屏幕成功持续点亮。
#### 2.触摸屏驱动移植（FT6336）
有了显示屏的经验，我继续移植电容触摸驱动。但在调试过程中，再次遇到了“硬件无响应”的问题。
>**问题：** 为了图省事，我起初只连接了 SDA、SCL、INT 三根线，认为复位引脚（RST）非必要（也就是悬空）。结果无论如何测试，程序都无法读取到触摸坐标，且串口无报错，看起来就像触摸芯片坏了一样。
>**根本原因：** 经过深入分析驱动库源码，我发现 ts.begin() 初始化函数中包含了 ts.reset() 操作，该操作需要拉动 RST 引脚产生复位时序来唤醒触摸芯片。在代码中若将 CTP_RST_PIN 设置为 -1（未连接），digitalWrite 操作无效，导致触摸芯片一直处于未复位或休眠状态，无法进行 I2C 通信。
>**解决：** 补接 RST 引脚并在代码中正确定义后，触摸功能恢复正常。
#### 3.LVGL 图形库适配
在底层驱动调通后，我进行了 LVGL 的移植工作。这不仅仅是修改配置文件，还需要完成显示缓冲区的分配以及输入设备的注册，将底层的 ST7796 绘图函数和触摸坐标数据与 LVGL 的核心引擎进行关联，最终成功在屏幕上渲染出了 UI 控件。
![alt text](image-1.png)


### 3.UI交互式界面设计
#### 1.开发工具链优化：引入 SquareLine Studio
在 UI 开发初期，我首先尝试直接使用 LVGL 原生库编写 C 代码。经过一段时间的学习，我发现网上的教程多基于 STM32，虽然底层逻辑与 ESP32 通用，但 LVGL 的控件布局、样式渲染和事件回调如果纯靠手写代码，代码量巨大且调试极其繁琐。

考虑到本项目核心在于“信号处理”与“定位算法”，UI 只是人机交互的窗口，不应在界面绘制上消耗过多时间成本。因此，我决定优化开发工具链，引入 SquareLine Studio 进行可视化开发。通过拖拽方式快速布局，自动生成标准的 LVGL C 代码。

并且将原本需要几天完成的界面排版工作压缩到几小时内，让我能腾出精力专注于底层逻辑的实现。只不过多花了一定时间用来学习如何使用 SquareLine Studio 软件。
#### 2.模拟信号波形产生
为了确保在 ADC 硬件调试完成前，UI 能够正常工作，我采用了 **软硬件解耦** 的开发策略。

首先，我深入研究了离子迁移谱的真实信号特征——通常是一组随时间变化的电压序列，包含反应物离子峰（RIP）和分析物离子峰。在没有真实传感器数据的情况下，我编写了一个信号发生器函数，利用数学公式（高斯函数模拟波峰）在数组中生成模拟的电压数据。

**接口预留：** 设计了通用的绘图接口。目前该接口读取模拟数组，在屏幕 Chart 控件上动态绘制波形。一旦外置 ADC 驱动调通，只需将数据源从“模拟数组”切换为“ADC 采集缓冲区”即可，无需改动 UI 层代码。
**难点：** 在进行这一功能时，需要用指针调用UI设计时波形曲线的句柄，以及对相关按键进行事件设计，再调用该事件函数，需要熟悉其相关函数用法，以及逻辑清晰。
#### 3. 关键技术难点与攻关
在使用 SquareLine 生成代码并结合 Arduino 逻辑时，我克服了以下技术挑战：
- **对象句柄与指针操作：** SquareLine 生成的 UI 控件（图表、标签）本质上是 lv_obj_t* 类型的指针句柄。在主程序中更新波形数据时，必须正确调用这些全局指针，否则会导致程序崩溃。
- **事件驱动逻辑设计：** 需要处理复杂的交互逻辑，例如点击“开始采集”按钮后，触发回调函数，改变系统状态标志位，进而启动模拟数据的生成与刷新。这要求我对 LVGL 的事件冒泡机制和 C 语言的函数指针有清晰的理解。
下图为软件设计的UI图：
![软件设计UI图](image-2.png)
下图为模拟产生的离子峰波形：
![alt text](image-4.jpg)
![alt text](image-3.jpg)


### 4.项目相关技术学习
随着项目代码量的急剧增加，原本简单的开发方式已经无法支撑复杂的系统构建。为了提高开发效率和代码的安全性，我对开发环境和工具链进行了全面升级。
#### 1.开发平台迁移：从 Arduino IDE 到 VS Code + PlatformIO
在项目初期，Arduino IDE 确实简单好用。但随着 UI 库、驱动文件和算法代码的不断堆叠，其弊端逐渐暴露：

- Arduino IDE 缺乏代码自动补全和函数跳转功能，导致我在调用 LVGL 的 API 时经常拼写错误；
- 它对多文件项目的管理非常简陋，无法直观地查看文件结构，编译速度也随着工程变大而显著变慢。

经过调研，我决定迁移至 Visual Studio Code 并搭载 PlatformIO 插件。我重新配置了 platformio.ini 配置文件，手动迁移了第三方库依赖，解决了头文件路径引用的报错问题。

迁移后，不仅拥有了强大的代码提示和跳转功能，还能通过 ini 文件精准控制编译参数。这使得我在处理包含数十个源文件的复杂工程时，效率提升了数倍。
#### 2.git分布式管理的学习
在项目进入“多模块融合”阶段后，我面临着巨大的风险：需要在保留 UI 界面功能的同时，嵌入 ADC 采集功能。一旦新代码导致系统崩溃，很难回退到上一个正常版本。为了解决这个问题，我系统地学习并使用了 Git。

例如在开发“ADC 采集”或“优化 UI”等新功能时，我会创建独立的分支。这样无论我怎么修改破坏，主分支的代码永远是稳定可运行的。并且利用 Git 的提交记录，我可以随时查看代码的修改历史。如果某次修改导致了 Bug，可以迅速回滚到之前的稳定版本，不再需要像以前那样手动复制文件夹备份。

配合 VS Code 内置的 Git 图形化工具，我实现了代码的规范化管理，为后续功能的叠加提供了“后悔药”和安全保障。

### 5.ADC采集信号的实现
#### 1.ADC采集模块的选型依据
针对离子迁移谱（IMS）信号微弱且瞬变的特性，我进行了详细的理论计算，最终选定了 TI 公司的 ADS8681 芯片（1 MSPS 采样率，16-bit 分辨率）。选型依据如下：
- **1M采样率：** 根据前期调研，IMS 谱图中单个离子峰的宽度通常在 50μs 左右。 选用 1 MSPS 的采样率，意味着每 1μs 采集一个数据点。这样，对于一个 50μs 宽的离子峰，我能采集到约 50 个采样点。 这完全有足够的点数来描绘波形。
- **16位分辨率：** 经过跨阻放大器后的电压信号满量程约为 5V。16-bit 的分辨率意味着将 5V 电压切分为 $2^{16} = 65536$ 份。计算可知，系统的最小分辨率为：$$5V / 65536 \approx 76 \mu V$$这意味着哪怕信号发生 0.076 mV 的微小变化也能被捕捉到，这对于分辨极低浓度的化学物质至关重要。
#### 2.ADC采集功能的实现
在软硬件联调阶段，我发现市面上该模块的例程几乎全基于 STM32 标准库或 HAL 库，其底层寄存器操作和 GPIO 调用方式与 ESP32-S3 完全不兼容。

为了解决这个问题，必须查阅 ADS8681 的官方数据手册，编写适用于 Arduino 框架的驱动程序：
- 通过分析芯片的时序图，确定了 SPI 通信的 CPOL（时钟极性）和 CPHA（时钟相位）模式，并配置 ESP32 的硬件 SPI 总线频率，使其能够匹配 ADC 的高速读写需求。
-  编写了底层读写函数。ADS8681 是 16 位 ADC，但 SPI 传输通常以 8 位为单位。我在代码中实现了高低字节的位移拼接，将接收到的两个 8 位数据合并为一个完整的 16 位电压值。
- 配置命令下发： 不仅是读取数据，还需要根据手册定义的指令集，通过 SPI 向芯片发送配置命令，设定其输入量程，最终成功实现了数据的正确读取。

在串口调试板块可以读出用手触摸ADC模块输入端时的电压值，说明功能实现。


### 6.ADC采集与UI显示集成及性能优化
#### 1.多任务并发与硬件资源调度
在完成了 ADC 驱动库的封装后，我面临着将“高速信号采集”与“高刷新率 UI”融合的挑战。由于两者都需要占用大量的 CPU 周期和 SPI 总线资源，简单的循环调用会导致界面卡顿或采样丢失。为此，我基于 FreeRTOS 和 ESP32-S3 的双核架构 进行了深度优化。

难点：
- **双核并行处理：** 为了彻底解决 CPU 资源争抢，我利用 ESP32-S3 的双核特性进行任务拆分：Core 0 专注运行 ADC 采集任务；Core 1 专门负责 LVGL 的界面绘制和用户交互逻辑。 这种非对称多处理架构，确保了两个核心各司其职，互不拖累。
- **SPI 总线独立隔离：** 屏幕驱动和 ADC 均依赖 SPI 通信。为了避免总线竞争我充分利用了芯片的硬件资源。用HSPI 总线分配给屏幕驱动。用FSPI 总线分配给 ADS8681 ADC，确保采集数据流的带宽不受干扰。
- **任务同步机制：** 虽然硬件上物理隔离，但数据需要交换。我引入了 FreeRTOS 的互斥锁和消息队列机制，在保证数据完整性的前提下，实现了“采集完成 -> 通知 UI 更新”的流水线作业。
#### 2.性能提升
在初步联调后，我发现了一个严重问题：虽然理论配置为 1 MSPS 采样率，但实测并未达到预期。通过分析 Arduino 底层源码，我发现标准的 SPI.transfer() 函数为了兼容性，包含了很多额外的判断语句和引脚检查操作。在 1MHz 的高频调用下，这些微小的软件开销被放大，导致两次采样之间的间隔被拉长，实际采样率跌至约 500kSPS。
**解决方案：** 直接寄存器访问，绕过 Arduino 的标准 SPI 库，直接操作 ESP32-S3 的 FSPI 硬件寄存器。通过直接向 SPI 数据寄存器写入指令并读取缓冲区，省去了所有中间层函数调用的开销。
#### 3.性能验证
可以用一个严谨的验证实验来确认采样率是否达标：
**测试方法：** 使用信号发生器输入一个 1 kHz 的标准方波（周期 1ms）。
**现象分析：**
- 优化前：在 UI 设定为 24ms 的时间窗口内，屏幕上只显示了约 12 个波形周期。这说明“时间被拉长了”，系统误以为采集了 24ms 的数据，实际上因为采样慢，花了 48ms 才填满缓冲区，导致显示的波形频率看起来减半（即实际采样率只有 500 kSPS）。
- 优化后：采用寄存器操作后，同样的 24ms 时间窗口内，屏幕精准显示了 24 个完整的方波周期。

**结论：** 波形周期与时间轴完美匹配 ，证明系统成功实现了 1 MSPS 的全速采样，性能达到理论极限。
下图为最终实际波形图（1kHz）：
![alt text](image-5.jpg)
下图为实物图：
![alt text](image-6.jpg)

### 7.采集功能与离子门脉冲信号的同步

#### 1.软件模拟同步方案（失败）

刚开始做这块的时候思路比较直接，想着用 CPU 直接控制 GPIO 引脚去“画”出高低电平。

具体的做法是：在代码里手动拉高电平开启离子门，然后立刻让 CPU 去启动 ADC 采集，并且让 CPU 在原地死等（阻塞），直到采集结束再处理数据。 但当把代码烧进去实际运行时，出现问题：整个系统直接卡死，点击屏幕上的“开始扫描”没有任何反应，界面也动不了。 经过排查和逻辑分析，我发现原方案存在严重缺陷：这种“软件死等”的方式占用了 100% 的 CPU 资源，直接导致了 RTOS的任务调度崩盘，UI 线程因为抢不到资源而饿死。而且，用软件翻转电平很难保证微秒级的时序精度，根本满足不了 IMS 的要求。所以我果断放弃了这个方案，推倒重来。

#### 2. LEDC 硬件外设 + GPIO 中断触发同步

启用了ESP32 内部的 LEDC（硬件 PWM）外设，把产生脉冲的工作完全交给了硬件定时器，这样无论 CPU 忙不忙，离子门信号都能以固定的频率稳定输出，完全释放了 CPU 资源。 其次，为了实现采集的“零延迟”启动，配置了 GPIO 上升沿中断。每当离子门打开的一瞬间，硬件中断会立马触发，利用 RTOS 的信号量机制，在微秒级的时间内唤醒独立的 ADC 采集任务。 改进后界面略有卡帧，但基本功能实现，波形成功显示，而且比较稳定，不再漂移。

这套方案实现了采集起点与离子门开启时刻的严格对齐，同时也保证了系统的流畅运行。

#### 3.系统逻辑描述

1.	在上电瞬间，系统完成基础设施搭建：分配大块内存用于存储海量数据（ADC采集），UI 界面绘制完成。同时，LEDC 硬件外设立即开始在引脚上产生脉冲信号。虽然脉冲在发，但由于扫描开关未打开，系统对这些信号“视而不见”，ADC 处于待机状态。
1.	当点击“开始扫描”按钮并且当 LEDC 信号产生**上升沿（从 0 变 1）**的那一微秒：离子门打开，离子群瞬间被放入漂移管，开始飞行。GPIO 硬件中断立即触发，强行打断 CPU 当前的所有低优先级工作（如 UI 刷新），以**零延迟**唤醒 ADC 采集任务。这确保了**软件采集的起点**与**物理离子进入的起点**严格对齐，实现同步。
1.	ADC 任务被唤醒后，立即启动高速采集，直到采集到分配的内存（刚好填满屏幕大小的数据，也就是1M SPS 采集24 ms）被填满为止。在前几毫秒，离子还在管子前段，ADC 采集到的是基线噪声和 RIP 峰。在中间时段，目标离子飞抵检测器，ADC 采集到离子峰电压。在结束时段，ADC 继续采集直到填满 24ms 的数据长度，确保捕捉到所有慢速离子。
1.	在 T=24ms 时，ADC 采集结束。此时距离下一个脉冲到来（T=30.3ms）还有约6ms 的空闲时间。在这 6ms 内，CPU 并没有闲着，它快速进行数据累加处理。
1.	系统重复上述过程。每采集完 1 次，就将这 24ms 的数据累加到缓存中。 当**攒够 16 个周期**（约 0.5 秒）后，将累加的数据除以 16，极大地消除了随机白噪声，让波形变光滑。利用 **“区间最大值”** 算法，将 24000 个高密度点压缩为 200 个屏幕像素点，确保即使极窄的离子峰也能在屏幕上显现，不会因为缩小而被“漏掉”。将处理好的波形刷新到 UI 界面，完成一次视觉更新。随后，清空缓存，准备迎接下一轮的 16 次循环。

- 在 T=24ms 时，ADC 采集结束。此时距离下一个脉冲到来（T=30.3ms）还有约6ms 的空闲时间。在这 6ms 内，CPU 并没有闲着，它快速进行数据累加处理。我的ADC采集任务和UI绘图在两个不同的核心，为什么还要留时间来进行绘图，不能同时进行吗

  这 6ms 的空闲时间，**主要是留给 Core 1（采集核）自己用的**，而不是给 Core 0（UI 核）用的。虽然你有两个核，但 Core 1 既负责“搬砖（采集）”也负责“砌墙（累加运算）”，它分身乏术，无法在同一时间既采数据又算数据。

- 我的离子门周期大小必须超过24 ms吗，我要是设置1 ms的周期会发生什么，那CPU此时不能边采集边进行数据处理吗

  若设置1ms的波形周期，此时会不断有离子峰涌入，谱图上不再有清晰的峰，而是一锅粥，造成“重叠干扰”。

- 我将产生离子门的引脚和ADC采集引脚接在了一块，产生如图所示的波形，这是什么原因(在 T=0 处有一个巨大的尖峰，后面全是平的。)
  ![alt text](D:/WorkSpace/技术日志/ESP32S3-IMSLAS/主线路（原稿）/1.jpg)
  离子门脉冲宽度只有 250µs (0.25ms) 或 500µs (0.5ms)。在屏幕上，这个脉冲只占非常窄的一瞬间。那个尖峰就是发出的离子门脉冲,因为它太短了，所以在长达 24ms 的图表上看起来就像一根针。

- 当我将该参数IMS_AVG_COUNT ，也就是累加次数改为4或者更低的数字后，我的屏幕上的波形就会一直向左移动，如果改为原来的16，就是固定在屏幕上，显示正常，这是什么原因

  采集完后，要进行**繁重的计算**（除法平均 + 200次峰值搜索 + 抢互斥锁 + 内存拷贝）。假设这套动作耗时 **4ms**。当设为 4 时，**繁重的计算**和**UI刷新**变得非常频繁，让 CPU 始终处于“高压状态”

### 8.离子迁移谱嵌入式系统功能验证
#### 1.实验参数设置
-  **控制信号：** 系统主控输出频率为 33 Hz、脉宽为 500 µs 的 3.3 V 逻辑电平信号，用于触发离子门驱动电路。
-  **高压工作参数：**
  >电离源电压：6000 V
  >漂移管电压：2000 V
  >离子门脉冲电压：400 V
#### 2.测试方法
采用对比验证法，将跨阻放大器的模拟输出端同时连接至本系统的 ADC 输入端与标准示波器，以评估系统采集结果的信号保真度与时序准确性。
#### 3.测试结果与分析（微电流放大器倍数为10^9）
![alt text](image-8.png)
![alt text](image-9.png)
测试结果如图所示。屏幕显示的谱图包络与示波器波形基本重合，准确还原了离子峰的上升沿与下降沿特征。双方显示的离子峰漂移时间高度吻合，从触发原点至离子峰顶点的漂移时间均为 5 ms，证明了系统 ADC 采集与离子门触发信号之间的同步逻辑精确无误。
观察到屏幕显示电压幅值与示波器读数存在比例差异。经分析，这主要源于显示比例缩放因子或探头衰减设置的校准偏差。尽管存在幅值缩放差异，但并不影响系统对离子迁移率的定性分析及相对强度的检测。

实验表明，本系统已成功实现微秒级脉冲控制与高灵敏度信号采集的集成，具备完整的离子迁移谱数据获取能力。


### 9.物质数据存储功能及UI实现

​	针对物质学习与校准这一核心功能，我目前已完成了从底层非易失性存储架构到上层复杂动态交互界面的全栈式开发工作。在界面交互层面，我并未采用简单的静态页面设计，而是基于 SquareLine Studio 深度定制了 UI 逻辑，通过引入 C++ 动态内存分配与 Flex 弹性布局算法，成功实现了列表项的实时实例化渲染与自动化对齐，解决了传统嵌入式 GUI 难以处理不定长数据的技术痛点，并攻克了分析界面与录入界面之间实时数据“定格”与上下文同步的交互难题；在底层数据与架构层面，为了确保校准参数具备工业级的安全性，我自主设计了基于 Flash (NVS) 分区的非易失性存储方案，通过构建专用的二进制数据结构映射与扇区读写算法，完整实现了数据的增删改查（CRUD）逻辑及掉电保护机制，确保系统即使在异常断电后重启也能毫秒级无损还原历史数据库；同时，我通过封装独立的管理器中间件解耦了业务逻辑与硬件驱动，最终构建了一个具备“示教学习”能力且拥有长久“记忆”功能的完整闭环系统。![4a924dec41a772af87b2977b3b92a157](image-7.jpg)

### 10.系统集成与机械结构设计

#### 1.PCB 布局与模块化集成
为了提升系统的便携性与抗干扰能力，本设计摒弃了早期的面包板连接方式，采用一体化 PCB 设计方案。
- **集成策略：** 将核心控制单元（ESP32-S3）、高精度信号采集模块（外置 ADC）以及人机交互界面（3.5英寸 TFT 屏幕）进行板级集成。

基于各元器件的数据手册（Datasheet）进行了严格的封装绘制，并辅以实物游标卡尺测量，确保了引脚间距与安装孔位的精确匹配。
PCB 采用 M3 铜柱进行多层堆叠式固定，既保证了结构的稳固性，又合理利用了垂直空间，实现了紧凑的硬件形态。 
![alt text](image-10.png)
![alt text](image-11.jpg)

#### 2.3D外壳设计与制造
为了保护内部电路并提供友好的操作界面，基于 PCB 的物理尺寸设计了专用外壳。使用 CAD 软件对组装后的 PCB 模组进行整体包络建模，精确预留了 Type-C 烧录代码接口、供电接口、信号输入SMA接口及离子门控制信号输出接口。
![alt text](image-12.png)
![alt text](image-13.jpg)