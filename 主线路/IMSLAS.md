# IMSLAS

## 一、硬件资源概述
### 1.核心开发板：ESP32S3
单片机型号：**ESP32-S3-WROOM-1-N16R8**
>**具体参数：**
>**N16:**  16 MB 的 Quad SPI Flash (闪存)
**R8:**  8 MB 的 Octal SPI PSRAM (伪静态随机存取存储器)

>**核心处理器 (CPU)**
核心： Xtensa® 双核 32-bit LX7 微处理器
时钟速度： 最高可达 240 MHz
片上内存 (SRAM)： 512 KB   
（这是“极速内存”,它就在 CPU 旁边，存取速度最快，但容量较小。
关键数据暂存： 用于存储程序的堆栈 (Stack)、中断服务程序 (ISR) 和最核心的变量。）
只读内存 (ROM)： 384 KB
（这是出厂时烧录好的“固化代码”，不可修改。它包含了 ESP32-S3 的启动程序 (Bootloader) 和一些基础的底层函数库（如蓝牙协议栈的底层）。它在幕后默默工作，确保芯片能启动。）
RTC 内存： 16 KB SRAM in RTC
（这是“低功耗内存”。当您让 ESP32-S3 进入深度睡眠 (Deep Sleep) 模式以省电时，主 CPU 会关闭，SRAM 数据会丢失，但 RTC 内存依然由电池（如有）供电保持数据。）

>**外部存储 (N16R8 的关键)**
Flash (闪存)： 16 MB (Quad SPI)
（用于存储您的程序、LVGL 库、图片、字体和数据库。这是您的“硬盘”。断电后数据不丢失。标准的 ESP32 通常只有 4MB，而您有 16MB，非常巨大。）
PSRAM (内存)： 8 MB (Octal SPI)
（用于 UI 绘图缓冲区、图表数据、ADC 采样阵列和深度学习模型。这是“扩展内存”。它的速度比 SRAM 慢一点，但比 Flash 快得多，而且容量是 SRAM 的 16 倍！）

>**无线通信**
Wi-Fi 协议： IEEE 802.11 b/g/n
Wi-Fi 频率： 2.4 GHz (2412 ~ 2484 MHz)
Wi-Fi 速率： 802.11n 模式下最高可达 150 Mbps
蓝牙协议： Bluetooth 5 (LE), 支持 Bluetooth mesh
蓝牙速率： 125 Kbps, 500 Kbps, 1 Mbps, 2 Mbps

### 2.屏幕介绍
屏幕介绍：https://www.lcdwiki.com/zh/3.5inch_IPS_SPI_Module_ST7796#%E4%BA%A7%E5%93%81%E5%9B%BE%E7%89%87
### 3.外置ADC介绍
#### 1.芯片型号：TI ADS8681 
> 分辨率：16 bit 
> 采样速率：1 MSPS (最大值) 
> 基准电压：内部 4.096V 
> 通道数：单通道 
> 输入阻抗：$\ge 1 M\Omega$  
> 输入接口：接线端子 或 SMA 
> 输入带宽：15 KHz  
> 输入量程 (软件可编程)：
    >>双极性量程：$\pm 2.56V$、$\pm 5.12V$、$\pm 6.144V$、$\pm 10.24V$、$\pm 12.288V$ 
    >>单极性量程：$0V \sim 5.12V$、$0V \sim 6.144V$、$0V \sim 10.24V$、$0V \sim 12.288V$
>    
> 通信与数字接口模块通信协议：SPI 
> 通信速率：66.67 MHz
#### 2.引脚功能
> 1.    CS (Chip Select / $\overline{CS}$):功能: 片选信号（低电平有效）。
>       操作: ESP32 拉低此脚以启动一帧数据传输（或启动一次转换，取决于配置）。传输结束后拉高。
> 2.    SCLK (Serial Clock):功能: 时钟信号。
>       操作: 由 ESP32 产生时钟脉冲，决定数据传输的快慢。ADS8681 支持最高 66.67 MHz 的时钟 ，完全匹配 ESP32 的高速 SPI 能力。
> 3.    SDI (Serial Data In / MOSI):功能: 数据输入（Master Out Slave In）。
>       操作: ESP32 通过此引脚向 ADC 发送命令。这在您的项目中非常重要，因为您需要通过 SDI 发送指令将输入量程配置为 0 ~ 5.12V 或 0 ~ 10.24V，否则默认量程可能不适合您的信号。
> 4.    SDO0 (Serial Data Out 0 / MISO):功能: 主数据输出（Master In Slave Out）。
>       操作: ADC 转换好的 16位数字信号通过此引脚传回 ESP32。这是您读取离子谱图数据的主要通道。 
> 5.    RST (Reset):功能: 硬件复位（低电平有效）。
      操作: 在系统上电初始化时，ESP32 应短暂拉低此引脚，确保 ADC 处于已知的初始状态。
> 6.    RVS (Read Valid Signal):功能: 数据有效/忙信号。这是 ADS8681 的一大特色。
>      操作:当 RVS 为 高电平 时，表示 ADC 正在输出有效数据或处于空闲状态;当 RVS 变低电平时，通常表示转换正在进行中。
> 7.    SDO1:功能: 第二数据输出（用于 Dual SPI 模式）。
>       操作: ADS8681 支持双线并行输出数据以加倍传输速度。


## 二、项目概况
**基于离子迁移谱的自主化学源定位系统（IMSLAS-Localization and Autonomous Seeking)**
本项目旨在开发一款**基于离子迁移谱的自主化学源定位系统(IMSLAS)**。与仅能对样本进行定性/定量分析的传统IMS设备不同，本系统在保留核心物质识别能力的基础上，创新性地实现了 **“识别 + 定位”一体化功能**。设备对目标物质（如特定危险品、污染物）进行“嗅探”校准，提取并存储该物质的离子迁移率谱图特征；将设备搭载于无人机或四足机器人等移动平台，在作业环境中实时监测目标物质的浓度梯度。系统利用**类生物趋化性算法（Chemotaxis Algorithm）**，根据浓度变化实时解算运动矢量，驱动平台向高浓度区域逼近，最终锁定目标物质的精确空间位置，实现从“发现”到“定位”的全自动闭环。本系统基于高性能双核MCU **ESP32-S3-WROOM-1-N16R8** 构建，采用 PlatformIO 开发环境与 Arduino 框架进行嵌入式软件开发。

按照系统架构，嵌入式软件开发被拆解为以下四个关键技术模块，每个模块都进行了深度的功能定义与逻辑细化：
1. **离子门控时序发生器**
   产生高精度的驱动信号，控制离子门的开闭时序。
2. **交互式人机界面设计**
   **核心任务：** 构建基于3.5英寸TFT屏幕的可视化操作终端。
   **硬件规格：** 分辨率320×480 (Pixel)，采用高效的4线SPI通讯接口；显示驱动IC为ST7796U，电容触摸驱动IC为FT6336U。
   **功能实现：** 设计基于事件驱动的UI架构，优化SPI传输效率（如使用DMA传输）以保证高刷新率。
   **六大功能模块划分：**
   1. **物质识别与分析（Analysis）：** 显示当前检测物质名称及置信度；
   2. **实时导航显示（Navigation）：** 显示平台运动轨迹、方向指引及相对位置；
   3. **浓度可视化（Concentration）：** 以波形或色阶形式直观呈现浓度变化趋势；
   4. **物质学习校准（Calibration）：** 录入新物质的谱图特征进行训练；
   5. **系统状态监测（Status）：** 监控高压源、温度、气流及电池电压；
   6. **系统设置（Settings）：** 调节离子门脉宽、采集增益等底层参数。
3. **高速数据采集与信号处理**
    核心任务是捕获微弱的离子流信号并转化为数字谱图。驱动外置高精度、高采样率ADC对经过放大的模拟信号进行离散化采集并且在屏幕上实时绘制“电压-时间”波形（即离子迁移谱图）。计算不同离子峰的**飞行时间（Time of Flight, ToF）**，结合漂移管长度与电场强度，反演计算出物质特有的**迁移率（$K_0$）**，以此作为物质识别的“指纹”依据。利用外置的高速高精度ADC采集电压信号（由离子门进来的被电离的物质产生的电流信号，再经过跨阻放大器得到电压信号），并且将波形呈现在屏幕上，记录不同物质离子的迁移率，根据此可以实现离子迁移谱分析仪的功能。
4. **定位算法设计**
   在实现能分辨出物质功能的前提下，设计循迹算法，使其能精准定位该物质源，并且其浓度和循迹过程可以显示在屏幕上。


## 三、项目工作内容及成果

### 1.从 MicroPython 开发框架转移到 Arduino 框架
项目初期，考虑到我本身具备一定的 Python 语言基础，且 MicroPython 语法简洁、易于上手，参考老师的建议，我决定优先尝试使用 Python 进行开发。 我选用了 Thonny 软件作为主要开发工具，完成了 ESP32-S3 的固件烧录，并结合 B 站等网络课程进行了基础功能的学习与验证。
随着开发的深入，特别是在涉及屏幕驱动和核心功能实现时，我发现 MicroPython 并不适合本项目的实际需求，主要原因如下:
> - 当我开始调研市面上的屏幕时，我发现市面上的商家提供的驱动例程绝大多数是基于 STM32 或 Arduino 平台的 C/C++ 代码。MicroPython 相关的驱动资源非常稀缺，甚至需要去 GitHub 上“碰运气”。对于嵌入式经验尚浅的我来说，如果没有现成的库，从零开始移植底层的屏幕驱动难度极大，且极易拖慢项目进度。
> - 网上的 Arduino 开发资料和社区支持远比 MicroPython 丰富。使用 Arduino 框架遇到问题更容易找到解决方案。
> - 本项目的一个核心功能是高速高精度 ADC 采集。MicroPython 本质上是解释型语言，其运行效率和对底层的控制能力天然弱于 C/C++。要实现百万级（1 MSPS）的采样速率并进行实时处理，C/C++（Arduino 的底层语言）是更合适的选择。

基于以上对开发生态和运行性能的双重考量，我决定及时调整技术路线，摒弃 MicroPython 环境，全面转用 Arduino 框架 进行后续开发。


### 2.移植屏幕相关驱动程序
选购到合适的屏幕硬件后，首要任务是打通“硬件-驱动-应用”的链路。本项目涉及 ST7796 显示驱动、触摸驱动以及 LVGL 图形库的移植与适配。
#### 1.显示屏驱动移植（ST7796）
由于初次接触嵌入式底层驱动，我对“移植”的概念比较模糊。经过查阅资料，我选择了在 Arduino 生态中功能强大且兼容性好的 TFT_eSPI 库作为基础进行适配。在理解了 SPI 总线定义、引脚映射（Pin Mapping）等基础概念后，我开始了实操调试。

**遇到的挑战：** 屏幕“闪退”问题。在完成 User_Setup.h 的引脚配置并烧录测试代码后，出现了一个奇怪的现象：屏幕在复位瞬间会点亮不到 1 秒（能看到测试文字，说明 SPI 通信正常），随后立即熄灭。
>**故障排查过程：**
**假设一：** 供电不足。我首先怀疑 ESP32-S3 的板载 LDO 无法承受屏幕启动瞬间的电流冲击（电压跌落导致芯片重启）。为了验证，我尝试将屏幕供电改接至 5V（商家标注该屏幕3.3V/5V供电都可行，找不到其它出错的可能，只能尝试5V供电是否可行），然而开发板上没有5V供电接口，只能去实验室进行试验，在接上5V电源后依然短暂亮起又熄灭，问题没解决。
**假设二：** 驱动逻辑冲突。排除硬件问题后，我重新审查软件配置。通过分析代码逻辑，我发现问题出在背光控制电平上：TFT_eSPI 库默认配置认为“高电平”开启背光（#define TFT_BACKLIGHT_ON HIGH），而我所使用的屏幕模块内部电路设计是低电平有效。因此，初始化完成后，驱动库发出的“开启”指令（High）实际上关闭了背光。
**解决方案：** 将宏定义修改为 #define TFT_BACKLIGHT_ON LOW 后，屏幕成功持续点亮。
#### 2.触摸屏驱动移植（FT6336）
有了显示屏的经验，我继续移植电容触摸驱动。但在调试过程中，再次遇到了“硬件无响应”的问题。
>**问题：** 为了图省事，我起初只连接了 SDA、SCL、INT 三根线，认为复位引脚（RST）非必要（也就是悬空）。结果无论如何测试，程序都无法读取到触摸坐标，且串口无报错，看起来就像触摸芯片坏了一样。
>**根本原因：** 经过深入分析驱动库源码，我发现 ts.begin() 初始化函数中包含了 ts.reset() 操作，该操作需要拉动 RST 引脚产生复位时序来唤醒触摸芯片。在代码中若将 CTP_RST_PIN 设置为 -1（未连接），digitalWrite 操作无效，导致触摸芯片一直处于未复位或休眠状态，无法进行 I2C 通信。
>**解决：** 补接 RST 引脚并在代码中正确定义后，触摸功能恢复正常。
#### 3.LVGL 图形库适配
在底层驱动调通后，我进行了 LVGL 的移植工作。这不仅仅是修改配置文件，还需要完成显示缓冲区的分配以及输入设备的注册，将底层的 ST7796 绘图函数和触摸坐标数据与 LVGL 的核心引擎进行关联，最终成功在屏幕上渲染出了 UI 控件。
![alt text](image-1.png)


### 3.UI交互式界面设计
#### 1.开发工具链优化：引入 SquareLine Studio
在 UI 开发初期，我首先尝试直接使用 LVGL 原生库编写 C 代码。经过一段时间的学习，我发现网上的教程多基于 STM32，虽然底层逻辑与 ESP32 通用，但 LVGL 的控件布局、样式渲染和事件回调如果纯靠手写代码，代码量巨大且调试极其繁琐。

考虑到本项目核心在于“信号处理”与“定位算法”，UI 只是人机交互的窗口，不应在界面绘制上消耗过多时间成本。因此，我决定优化开发工具链，引入 SquareLine Studio 进行可视化开发。通过拖拽方式快速布局，自动生成标准的 LVGL C 代码。

并且将原本需要几天完成的界面排版工作压缩到几小时内，让我能腾出精力专注于底层逻辑的实现。只不过多花了一定时间用来学习如何使用 SquareLine Studio 软件。
#### 2.模拟信号波形产生
为了确保在 ADC 硬件调试完成前，UI 能够正常工作，我采用了 **软硬件解耦** 的开发策略。

首先，我深入研究了离子迁移谱的真实信号特征——通常是一组随时间变化的电压序列，包含反应物离子峰（RIP）和分析物离子峰。在没有真实传感器数据的情况下，我编写了一个信号发生器函数，利用数学公式（高斯函数模拟波峰）在数组中生成模拟的电压数据。

**接口预留：** 设计了通用的绘图接口。目前该接口读取模拟数组，在屏幕 Chart 控件上动态绘制波形。一旦外置 ADC 驱动调通，只需将数据源从“模拟数组”切换为“ADC 采集缓冲区”即可，无需改动 UI 层代码。
**难点：** 在进行这一功能时，需要用指针调用UI设计时波形曲线的句柄，以及对相关按键进行事件设计，再调用该事件函数，需要熟悉其相关函数用法，以及逻辑清晰。
#### 3. 关键技术难点与攻关
在使用 SquareLine 生成代码并结合 Arduino 逻辑时，我克服了以下技术挑战：
- **对象句柄与指针操作：** SquareLine 生成的 UI 控件（图表、标签）本质上是 lv_obj_t* 类型的指针句柄。在主程序中更新波形数据时，必须正确调用这些全局指针，否则会导致程序崩溃。
- **事件驱动逻辑设计：** 需要处理复杂的交互逻辑，例如点击“开始采集”按钮后，触发回调函数，改变系统状态标志位，进而启动模拟数据的生成与刷新。这要求我对 LVGL 的事件冒泡机制和 C 语言的函数指针有清晰的理解。
下图为软件设计的UI图：
![软件设计UI图](image-2.png)
下图为模拟产生的离子峰波形：
![alt text](image-4.jpg)
![alt text](image-3.jpg)


### 4.项目相关技术学习
随着项目代码量的急剧增加，原本简单的开发方式已经无法支撑复杂的系统构建。为了提高开发效率和代码的安全性，我对开发环境和工具链进行了全面升级。
#### 1.开发平台迁移：从 Arduino IDE 到 VS Code + PlatformIO
在项目初期，Arduino IDE 确实简单好用。但随着 UI 库、驱动文件和算法代码的不断堆叠，其弊端逐渐暴露：

- Arduino IDE 缺乏代码自动补全和函数跳转功能，导致我在调用 LVGL 的 API 时经常拼写错误；
- 它对多文件项目的管理非常简陋，无法直观地查看文件结构，编译速度也随着工程变大而显著变慢。

经过调研，我决定迁移至 Visual Studio Code 并搭载 PlatformIO 插件。我重新配置了 platformio.ini 配置文件，手动迁移了第三方库依赖，解决了头文件路径引用的报错问题。

迁移后，不仅拥有了强大的代码提示和跳转功能，还能通过 ini 文件精准控制编译参数。这使得我在处理包含数十个源文件的复杂工程时，效率提升了数倍。
#### 2.git分布式管理的学习
在项目进入“多模块融合”阶段后，我面临着巨大的风险：需要在保留 UI 界面功能的同时，嵌入 ADC 采集功能。一旦新代码导致系统崩溃，很难回退到上一个正常版本。为了解决这个问题，我系统地学习并使用了 Git。

例如在开发“ADC 采集”或“优化 UI”等新功能时，我会创建独立的分支。这样无论我怎么修改破坏，主分支的代码永远是稳定可运行的。并且利用 Git 的提交记录，我可以随时查看代码的修改历史。如果某次修改导致了 Bug，可以迅速回滚到之前的稳定版本，不再需要像以前那样手动复制文件夹备份。

配合 VS Code 内置的 Git 图形化工具，我实现了代码的规范化管理，为后续功能的叠加提供了“后悔药”和安全保障。

### 5.ADC采集信号的实现
#### 1.ADC采集模块的选型依据
针对离子迁移谱（IMS）信号微弱且瞬变的特性，我进行了详细的理论计算，最终选定了 TI 公司的 ADS8681 芯片（1 MSPS 采样率，16-bit 分辨率）。选型依据如下：
- **1M采样率：** 根据前期调研，IMS 谱图中单个离子峰的宽度通常在 50μs 左右。 选用 1 MSPS 的采样率，意味着每 1μs 采集一个数据点。这样，对于一个 50μs 宽的离子峰，我能采集到约 50 个采样点。 这完全有足够的点数来描绘波形。
- **16位分辨率：** 经过跨阻放大器后的电压信号满量程约为 5V。16-bit 的分辨率意味着将 5V 电压切分为 $2^{16} = 65536$ 份。计算可知，系统的最小分辨率为：$$5V / 65536 \approx 76 \mu V$$这意味着哪怕信号发生 0.076 mV 的微小变化也能被捕捉到，这对于分辨极低浓度的化学物质至关重要。
#### 2.ADC采集功能的实现
在软硬件联调阶段，我发现市面上该模块的例程几乎全基于 STM32 标准库或 HAL 库，其底层寄存器操作和 GPIO 调用方式与 ESP32-S3 完全不兼容。

为了解决这个问题，必须查阅 ADS8681 的官方数据手册，编写适用于 Arduino 框架的驱动程序：
- 通过分析芯片的时序图，确定了 SPI 通信的 CPOL（时钟极性）和 CPHA（时钟相位）模式，并配置 ESP32 的硬件 SPI 总线频率，使其能够匹配 ADC 的高速读写需求。
-  编写了底层读写函数。ADS8681 是 16 位 ADC，但 SPI 传输通常以 8 位为单位。我在代码中实现了高低字节的位移拼接，将接收到的两个 8 位数据合并为一个完整的 16 位电压值。
- 配置命令下发： 不仅是读取数据，还需要根据手册定义的指令集，通过 SPI 向芯片发送配置命令，设定其输入量程，最终成功实现了数据的正确读取。

在串口调试板块可以读出用手触摸ADC模块输入端时的电压值，说明功能实现。


### 6.ADC采集与UI显示集成及性能优化
#### 1.多任务并发与硬件资源调度
在完成了 ADC 驱动库的封装后，我面临着将“高速信号采集”与“高刷新率 UI”融合的挑战。由于两者都需要占用大量的 CPU 周期和 SPI 总线资源，简单的循环调用会导致界面卡顿或采样丢失。为此，我基于 FreeRTOS 和 ESP32-S3 的双核架构 进行了深度优化。

难点：
- **双核并行处理：** 为了彻底解决 CPU 资源争抢，我利用 ESP32-S3 的双核特性进行任务拆分：Core 0 专注运行 ADC 采集任务；Core 1 专门负责 LVGL 的界面绘制和用户交互逻辑。 这种非对称多处理架构，确保了两个核心各司其职，互不拖累。
- **SPI 总线独立隔离：** 屏幕驱动和 ADC 均依赖 SPI 通信。为了避免总线竞争我充分利用了芯片的硬件资源。用HSPI 总线分配给屏幕驱动。用FSPI 总线分配给 ADS8681 ADC，确保采集数据流的带宽不受干扰。
- **任务同步机制：** 虽然硬件上物理隔离，但数据需要交换。我引入了 FreeRTOS 的互斥锁和消息队列机制，在保证数据完整性的前提下，实现了“采集完成 -> 通知 UI 更新”的流水线作业。
#### 2.性能提升
在初步联调后，我发现了一个严重问题：虽然理论配置为 1 MSPS 采样率，但实测并未达到预期。通过分析 Arduino 底层源码，我发现标准的 SPI.transfer() 函数为了兼容性，包含了很多额外的判断语句和引脚检查操作。在 1MHz 的高频调用下，这些微小的软件开销被放大，导致两次采样之间的间隔被拉长，实际采样率跌至约 500kSPS。
**解决方案：** 直接寄存器访问，绕过 Arduino 的标准 SPI 库，直接操作 ESP32-S3 的 FSPI 硬件寄存器。通过直接向 SPI 数据寄存器写入指令并读取缓冲区，省去了所有中间层函数调用的开销。
#### 3.性能验证
可以用一个严谨的验证实验来确认采样率是否达标：
**测试方法：** 使用信号发生器输入一个 1 kHz 的标准方波（周期 1ms）。
**现象分析：**
- 优化前：在 UI 设定为 24ms 的时间窗口内，屏幕上只显示了约 12 个波形周期。这说明“时间被拉长了”，系统误以为采集了 24ms 的数据，实际上因为采样慢，花了 48ms 才填满缓冲区，导致显示的波形频率看起来减半（即实际采样率只有 500 kSPS）。
- 优化后：采用寄存器操作后，同样的 24ms 时间窗口内，屏幕精准显示了 24 个完整的方波周期。

**结论：** 波形周期与时间轴完美匹配 ，证明系统成功实现了 1 MSPS 的全速采样，性能达到理论极限。
下图为最终实际波形图（1kHz）：
![alt text](image-5.jpg)
下图为实物图：
![alt text](image-6.jpg)